// Package vogen provides a code generator for Value Objects in Go.
// Value Objects are immutable objects that represent a value.
package vogen

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"

	"github.com/iancoleman/strcase"
)

// ValueObject is set to the metadata of the ValueObject to be automatically generated.
type ValueObject struct {
	// StructName is the name of the struct to be generated.
	// Required field.
	StructName string
	// Fields is the list of fields to be generated.
	// Required field.
	Fields []Field
	// Comments is the struct comment to be generated.
	// No need to add '//' to indicate the start of a comment.
	// Optional Field. If not specified, the struct comment is automatically generated.
	Comments []string
	// Imports is the list of imports to be generated.
	// Optional Field.
	Imports []string
}

// Field is set to the metadata of the field to be automatically generated.
type Field struct {
	// Name is the name of the field to be generated.
	// The name specified in Name is always converted to 'lowerCamelCase'.
	// Required field.
	Name string
	// Type is the type of the field to be generated.
	// Type can be a primitive type or a Defined type. If you specify a Defined type, you must specify package import.
	// Required field.
	Type string
	// Comments is the field comment to be generated.
	// No need to add '//' to indicate the start of a comment.
	// Optional Field. If not specified, the field comment is to be empty.
	Comments []string
	// Validators is the list of validators to be generated.
	// The validation code is written within the New method. No check is made to see if the validation can be performed.
	// For example, it is possible to generate code that performs minimum value validation (incorrect code) for a string type.
	// Optional Field.
	Validators []Validator
}

// lowerCamelCase returns the field name converted to 'lowerCamelCase'.
func (f Field) lowerCamelCase() string {
	return strcase.ToLowerCamel(f.Name)
}

// Vogen is the main struct of the vogen package.
// Vogen generates a ValueObject based on the metadata set in ValueObject.
type Vogen struct {
	// filePath is the path to the file to be generated.
	// By default, the file is generated in the current directory. File name is value_object.go.
	filePath string
	// packageName is the name of the package to be generated.
	// By default, the package name is 'vo'.
	packageName string
	// valueObjects is the list of valueObjects to be generated.
	valueObjects []ValueObject
	// code is the list of code to be generated.
	code []string
}

// New creates a new Vogen struct.
func New(opts ...Option) (*Vogen, error) {
	vogen := &Vogen{
		filePath:     "value_object.go",
		packageName:  "vo",
		valueObjects: []ValueObject{},
		code:         []string{},
	}
	for _, opt := range opts {
		if err := opt(vogen); err != nil {
			return nil, err
		}
	}
	return vogen, nil
}

// AppendValueObjects appends ValueObjects to the Vogen struct.
func (vo *Vogen) AppendValueObjects(vos ...ValueObject) error {
	if err := vo.validate(vos...); err != nil {
		return err
	}
	vo.valueObjects = append(vo.valueObjects, vos...)
	return nil
}

// validate validates the ValueObject.
// If the error occurs, it returns the first error.
func (vo *Vogen) validate(vos ...ValueObject) error {
	for _, v := range vos {
		if v.StructName == "" {
			return ErrStructNameEmpty
		}
		if len(v.Fields) == 0 {
			return ErrInvalidField
		}
		for _, f := range v.Fields {
			if f.Name == "" {
				return ErrInvalidFieldName
			}
			if f.Type == "" {
				return ErrInvalidFieldType
			}
		}
	}
	return nil
}

// Generate generates ValueObject code and writes it to the specified file path.
func (vo *Vogen) Generate() error {
	vo.code = append(vo.code, "// Code generated by vogen. DO NOT EDIT.\n")
	vo.code = append(vo.code, fmt.Sprintf("package %s\n\n", vo.packageName))
	vo.writeImports()

	for _, valueObject := range vo.valueObjects {
		vo.writeStruct(valueObject)
		vo.writeConstructor(valueObject)
		vo.writeConstructorWithValidator(valueObject)
		vo.writeGetters(valueObject)
		vo.writeEqualMethod(valueObject)
	}
	return vo.generateFile()
}

// writeImports writes the import statements to the code.
func (vo *Vogen) writeImports() {
	importSet := map[string]struct{}{}

	importSet["fmt"] = struct{}{}
	for _, valueObject := range vo.valueObjects {
		for _, imp := range valueObject.Imports {
			importSet[imp] = struct{}{}
		}
	}

	vo.code = append(vo.code, "import (\n")
	for imp := range importSet {
		vo.code = append(vo.code, fmt.Sprintf("\t\"%s\"\n", imp))
	}
	vo.code = append(vo.code, ")\n\n")
}

// writeStruct writes the struct to the code.
func (vo *Vogen) writeStruct(valueObject ValueObject) {
	if len(valueObject.Comments) > 0 {
		for _, comment := range valueObject.Comments {
			vo.code = append(vo.code, fmt.Sprintf("// %s\n", comment))
		}
	} else {
		vo.code = append(vo.code, fmt.Sprintf("// %s represents a value object.\n", valueObject.StructName))
	}

	vo.code = append(vo.code, fmt.Sprintf("type %s struct {\n", valueObject.StructName))
	for _, field := range valueObject.Fields {
		for _, comment := range field.Comments {
			vo.code = append(vo.code, fmt.Sprintf("\t// %s\n", comment))
		}
		vo.code = append(vo.code, fmt.Sprintf("\t%s %s\n", field.lowerCamelCase(), field.Type))
	}
	vo.code = append(vo.code, "}\n\n")
}

// writeConstructor writes the constructor to the code.
func (vo *Vogen) writeConstructor(valueObject ValueObject) {
	constructorArgs := []string{}
	constructorInit := []string{}
	for _, field := range valueObject.Fields {
		constructorArgs = append(constructorArgs, fmt.Sprintf("%s %s", field.lowerCamelCase(), field.Type))
		constructorInit = append(constructorInit, fmt.Sprintf("%s: %s", field.lowerCamelCase(), field.lowerCamelCase()))
	}
	vo.code = append(vo.code, fmt.Sprintf("// New%s creates a new instance of %s.\n", valueObject.StructName, valueObject.StructName))
	vo.code = append(vo.code, fmt.Sprintf("func New%s(%s) %s {\n", valueObject.StructName, strings.Join(constructorArgs, ", "), valueObject.StructName))
	vo.code = append(vo.code, fmt.Sprintf("\treturn %s{%s}\n", valueObject.StructName, strings.Join(constructorInit, ", ")))
	vo.code = append(vo.code, "}\n\n")
}

// writeConstructorWithValidator writes the constructor with validator to the code.
func (vo *Vogen) writeConstructorWithValidator(valueObject ValueObject) {
	existValidator := false
	for _, field := range valueObject.Fields {
		if len(field.Validators) == 0 {
			continue
		}
		existValidator = true
		break
	}
	if !existValidator {
		return
	}

	constructorArgs := []string{}
	constructorInit := []string{}
	for _, field := range valueObject.Fields {
		constructorArgs = append(constructorArgs, fmt.Sprintf("%s %s", field.lowerCamelCase(), field.Type))
		constructorInit = append(constructorInit, fmt.Sprintf("%s: %s", field.lowerCamelCase(), field.lowerCamelCase()))
	}
	vo.code = append(vo.code, fmt.Sprintf("// New%sStrictly creates a new instance of %s with validation.\n", valueObject.StructName, valueObject.StructName))
	vo.code = append(vo.code, fmt.Sprintf("func New%sStrictly(%s) (%s, error) {\n", valueObject.StructName, strings.Join(constructorArgs, ", "), valueObject.StructName))
	vo.code = append(vo.code, fmt.Sprintf("\to := %s{%s}\n", valueObject.StructName, strings.Join(constructorInit, ", ")))
	for _, field := range valueObject.Fields {
		for _, validator := range field.Validators {
			validator.write(vo, valueObject.StructName, field)
		}
	}
	vo.code = append(vo.code, "\treturn o, nil\n")
	vo.code = append(vo.code, "}\n\n")
}

// writeGetters writes the getter methods to the code.
func (vo *Vogen) writeGetters(valueObject ValueObject) {
	for _, field := range valueObject.Fields {
		vo.code = append(vo.code, fmt.Sprintf("// %s returns the %s field.\n", field.Name, field.lowerCamelCase()))
		vo.code = append(vo.code, fmt.Sprintf("func (o %s) %s() %s {\n", valueObject.StructName, field.Name, field.Type))
		vo.code = append(vo.code, fmt.Sprintf("\treturn o.%s\n", field.lowerCamelCase()))
		vo.code = append(vo.code, "}\n\n")
	}
}

// writeEqualMethod writes the Equal method to the code.
func (vo *Vogen) writeEqualMethod(valueObject ValueObject) {
	equalChecks := []string{}
	for _, field := range valueObject.Fields {
		equalChecks = append(equalChecks, fmt.Sprintf("o.%s() == other.%s()", field.Name, field.Name))
	}
	vo.code = append(vo.code, fmt.Sprintf("// Equal checks if two %s objects are equal.\n", valueObject.StructName))
	vo.code = append(vo.code, fmt.Sprintf("func (o %s) Equal(other %s) bool {\n", valueObject.StructName, valueObject.StructName))
	vo.code = append(vo.code, fmt.Sprintf("\treturn %s\n", strings.Join(equalChecks, " && ")))
	vo.code = append(vo.code, "}\n\n")
}

// generateFile generates the file based on the code and writes it to the specified file path.
func (vo *Vogen) generateFile() error {
	formattedCode, err := format.Source([]byte(strings.Join(vo.code, "")))
	if err != nil {
		return fmt.Errorf("failed to format source code: %w", err)
	}
	dir := filepath.Dir(vo.filePath)
	if err := os.MkdirAll(dir, 0750); err != nil {
		return fmt.Errorf("failed to create directories for file path %s: %w", vo.filePath, err)
	}
	if err := os.WriteFile(vo.filePath, formattedCode, 0600); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}
	return nil
}
