// Package vogen provides a code generator for Value Objects in Go.
// Value Objects are immutable objects that represent a value.
package vogen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
)

// ValueObject is set to the metadata of the ValueObject to be automatically generated.
type ValueObject struct {
	// StructName is the name of the struct to be generated.
	// required.
	StructName string
	// Fields is the list of fields to be generated.
	// required.
	Fields []Field
	// Imports is the list of imports to be generated.
	// optional.
	Imports []string
}

// Field is set to the metadata of the field to be automatically generated.
type Field struct {
	// Name is the name of the field to be generated.
	// The name specified in Name is always converted to Lowercase.
	// required.
	Name string
	// Type is the type of the field to be generated.
	// Type can be a primitive type or a Defined type. If you specify a Defined type, you must specify package import.
	// required.
	Type string
}

// lowercaseName returns the field name in lowercase.
func (f Field) lowercaseName() string {
	return strings.ToLower(f.Name)
}

// Vogen is the main struct of the vogen package.
// Vogen generates a ValueObject based on the metadata set in ValueObject.
type Vogen struct {
	// filePath is the path to the file to be generated.
	// By default, the file is generated in the current directory. File name is value_object.go.
	filePath string
	// packageName is the name of the package to be generated.
	// By default, the package name is 'vo'.
	packageName string
	// valueObjects is the list of valueObjects to be generated.
	valueObjects []ValueObject
	// buf is the buffer to write the generated code.
	buf bytes.Buffer
}

// New creates a new Vogen struct.
func New(opts ...Option) (*Vogen, error) {
	vogen := &Vogen{
		filePath:    "value_object.go",
		packageName: "vo",
	}
	for _, opt := range opts {
		if err := opt(vogen); err != nil {
			return nil, err
		}
	}
	return vogen, nil
}

// AppendValueObjects appends ValueObjects to the Vogen struct.
func (vo *Vogen) AppendValueObjects(vos ...ValueObject) error {
	if err := vo.validate(vos...); err != nil {
		return err
	}
	for _, v := range vos {
		vo.valueObjects = append(vo.valueObjects, v)
	}
	return nil
}

// validate validates the ValueObject.
// If the error occurs, it returns the first error.
func (vo *Vogen) validate(vos ...ValueObject) error {
	for _, v := range vos {
		if v.StructName == "" {
			return ErrStructNameEmpty
		}
		if len(v.Fields) == 0 {
			return ErrInvalidFieldName
		}
		for _, f := range v.Fields {
			if f.Name == "" {
				return ErrInvalidFieldName
			}
			if f.Type == "" {
				return ErrInvalidFieldType
			}
		}
	}
	return nil
}

// Generate generates ValueObject code and writes it to the specified file path.
func (vo *Vogen) Generate() error {
	vo.buf.Reset()

	if err := vo.writePackage(); err != nil {
		return fmt.Errorf("failed to write package declaration: %w", err)
	}

	if err := vo.writeImports(); err != nil {
		return fmt.Errorf("failed to write imports: %w", err)
	}

	for _, valueObject := range vo.valueObjects {
		if err := vo.writeStruct(valueObject); err != nil {
			return fmt.Errorf("failed to write struct for %s: %w", valueObject.StructName, err)
		}

		if err := vo.writeConstructor(valueObject); err != nil {
			return fmt.Errorf("failed to write constructor for %s: %w", valueObject.StructName, err)
		}

		if err := vo.writeGetters(valueObject); err != nil {
			return fmt.Errorf("failed to write getters for %s: %w", valueObject.StructName, err)
		}

		if err := vo.writeEqualMethod(valueObject); err != nil {
			return fmt.Errorf("failed to write Equal method for %s: %w", valueObject.StructName, err)
		}
	}

	if err := vo.generateFile(); err != nil {
		return fmt.Errorf("failed to generate file: %w", err)
	}

	return nil
}

// writePackage writes the package declaration.
func (vo *Vogen) writePackage() error {
	if _, err := vo.buf.WriteString("// Code generated by vogen. DO NOT EDIT.\n"); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString(fmt.Sprintf("package %s\n\n", vo.packageName)); err != nil {
		return err
	}
	return nil
}

// writeImports writes the import statements, deduplicating imports.
func (vo *Vogen) writeImports() error {
	importSet := map[string]struct{}{}
	for _, valueObject := range vo.valueObjects {
		for _, imp := range valueObject.Imports {
			importSet[imp] = struct{}{}
		}
	}

	if len(importSet) > 0 {
		if _, err := vo.buf.WriteString("import (\n"); err != nil {
			return err
		}
		for imp := range importSet {
			if _, err := vo.buf.WriteString(fmt.Sprintf("\t\"%s\"\n", imp)); err != nil {
				return err
			}
		}
		if _, err := vo.buf.WriteString(")\n\n"); err != nil {
			return err
		}
	}
	return nil
}

// writeStruct writes the struct definition for a ValueObject.
func (vo *Vogen) writeStruct(valueObject ValueObject) error {
	if _, err := vo.buf.WriteString(fmt.Sprintf("// %s represents a value object.\n", valueObject.StructName)); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString(fmt.Sprintf("type %s struct {\n", valueObject.StructName)); err != nil {
		return err
	}
	for _, field := range valueObject.Fields {
		if _, err := vo.buf.WriteString(fmt.Sprintf("\t%s %s\n", field.lowercaseName(), field.Type)); err != nil {
			return err
		}
	}
	if _, err := vo.buf.WriteString("}\n\n"); err != nil {
		return err
	}
	return nil
}

// writeConstructor writes the constructor function for a ValueObject.
func (vo *Vogen) writeConstructor(valueObject ValueObject) error {
	constructorArgs := []string{}
	constructorInit := []string{}
	for _, field := range valueObject.Fields {
		constructorArgs = append(constructorArgs, fmt.Sprintf("%s %s", field.lowercaseName(), field.Type))
		constructorInit = append(constructorInit, fmt.Sprintf("%s: %s", field.lowercaseName(), field.lowercaseName()))
	}

	if _, err := vo.buf.WriteString(fmt.Sprintf("// New%s creates a new instance of %s.\n", valueObject.StructName, valueObject.StructName)); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString(fmt.Sprintf("func New%s(%s) %s {\n", valueObject.StructName, strings.Join(constructorArgs, ", "), valueObject.StructName)); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString(fmt.Sprintf("\treturn %s{%s}\n", valueObject.StructName, strings.Join(constructorInit, ", "))); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString("}\n\n"); err != nil {
		return err
	}
	return nil
}

// writeGetters writes getter methods for each field of a ValueObject.
func (vo *Vogen) writeGetters(valueObject ValueObject) error {
	for _, field := range valueObject.Fields {
		if _, err := vo.buf.WriteString(fmt.Sprintf("// %s returns the %s field.\n", field.Name, field.lowercaseName())); err != nil {
			return err
		}
		if _, err := vo.buf.WriteString(fmt.Sprintf("func (o %s) %s() %s {\n", valueObject.StructName, field.Name, field.Type)); err != nil {
			return err
		}
		if _, err := vo.buf.WriteString(fmt.Sprintf("\treturn o.%s\n", field.lowercaseName())); err != nil {
			return err
		}
		if _, err := vo.buf.WriteString("}\n\n"); err != nil {
			return err
		}
	}
	return nil
}

// writeEqualMethod writes the Equal method for a ValueObject.
func (vo *Vogen) writeEqualMethod(valueObject ValueObject) error {
	equalChecks := []string{}
	for _, field := range valueObject.Fields {
		equalChecks = append(equalChecks, fmt.Sprintf("o.%s() == other.%s()", field.Name, field.Name))
	}

	if _, err := vo.buf.WriteString(fmt.Sprintf("// Equal checks if two %s objects are equal.\n", valueObject.StructName)); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString(fmt.Sprintf("func (o %s) Equal(other %s) bool {\n", valueObject.StructName, valueObject.StructName)); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString(fmt.Sprintf("\treturn %s\n", strings.Join(equalChecks, " && "))); err != nil {
		return err
	}
	if _, err := vo.buf.WriteString("}\n\n"); err != nil {
		return err
	}
	return nil
}

// generateFile generates the ValueObject code and writes it to the specified file path.
func (vo *Vogen) generateFile() error {
	formattedCode, err := format.Source(vo.buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format source code: %w", err)
	}
	dir := filepath.Dir(vo.filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directories for file path %s: %w", vo.filePath, err)
	}
	if err := os.WriteFile(vo.filePath, formattedCode, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}
	return nil
}
